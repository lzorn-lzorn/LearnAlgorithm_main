# 堆
## 堆的性质
堆，其在物理上是一个线性结构，在逻辑上是一个完全二叉树。

其中，每一个元素应该满足一个大前提： **堆内的元素应该是可比较的** 在此前提下，
堆顶（物理上是数组第一个元素，逻辑上是完全二叉树的根节点）的元素必须是所有元素中最能满足该比较性质的元素。
如果是 数字类型，则堆顶的元素应该是最大的和最小的。
同时，每个子树（在逻辑结构的角度）的根节点应该是在这个子树中满足最能满足该比较性质的元素。

总结一句话就是：**堆内的元素应该是可比较的，且每个子树的根节点应该是在子树中最能满足该比较性质的元素**

## 逻辑结构与物理结构的对应
逻辑结构和物理结构能比较好做到一一对应的前提是：两种结构都是稠密的，也就是每个索引都有对应的元素，中间不会空出来。

所以，根据完全二叉树的性质，假设其根节点的物理索引是 $i$, 则其左孩子的索引则为 $2i$，其右孩子的索引是 $2i+1$
这样的索引对应的前提是 从 1 开始数。也就是如果在数组中第一个元素空置（arr[0]不存元素）从第二个位置开始存储元素。如果是按照计算机的计数规则（从0开始数），则索引的对应全部往后平移一位。
即，若其根节点的物理索引是 $i$, 则其左孩子的索引则为 $2i+1$，其右孩子的索引是 $2i+2$

## 堆的核心操作-down()
定义两个元素之间的比较操作 cmp(Type a, Type b) 如果元素a 更满足这个比较性质，则返回true，反之返回false。
如果元素是数字类型cmp可以是less或者greater

最简化的情况：只有三个元素：p，l，r，其中p是根节点，l是其左孩子(左子树的根节点)，r是其右孩子(右子树的根节点)
down()的目标就是从这三个中找到最符合cmp的元素，并把其换到根节点的位置。这个行为可以递归的进行下去，或者迭代的进行下去。但是无论是递归还是迭代，都应该是从最后一个非叶子节点开始倒着建堆。
![image](https://github.com/lzorn-lzorn/LearnAlgorithm_main/assets/66933265/2fcf423d-e5fe-4f9b-9139-d00ac2af1d5d)

## 堆排序
如果希望实现堆内元素的排序，只要每次输出堆顶的元素，然后将堆顶的元素和堆尾的元素交换，再次建堆；再输出。这样循环往复即可完成排序。
需要注意的是，如果是输出元素再交换 是正序的输出。如果是交换元素之后再次交换倒数第二个元素，直到全部结束后统一输出则应该是倒序输出。

堆排序的时间复杂度是 $O(n\log{n})$。
down操作: 对于一个有 $n$ 个元素的堆，堆顶的元素最差情况要下到最后一个层，也就是要下 $\left \lceil \log{n} \right \rceil$ 层(实际上这里是否向上取整是不一定的，他可能不会在左边而是在右边就会少下一层)。所以down()的时间复杂度是 $O(\log{n})$

而我们需要对每一个元素都都进行一次(实际上在建堆的时候只需要对一半的元素，也就是非也叶子节点进行建堆即可，但是时间复杂度是不关心 $\frac{1}{2}$ 这个常数的)，所以其时间复杂都是$O(n)$

所以最后的复杂度是 $O(n\log{n})$

### 完整的数学证明
以下给出down()复杂度严格的推导：

$[Lemma1]$ 一个具有 $n$ 个节点的完全二叉树，其根的子树的节点数不会超过 $\frac{2}{3}n$

$proof$ :
由数学归纳法：当 $n=1,2,3$ 时， 结论成立。
设当完全二叉树有 $k$ 层时，结论也成立。
由完全二叉树的性质，除了最后一层外，其它每层节点数都是满的，且最后一层的节点都是从左到右填充的，则不妨设对于有 $n$ 个节点的完全二叉树，假设其中 $k$ 层是满的，则前 $k$ 层的节点总数是

$$
2^0+2^1+...+2^{k-1}=2^k-1
$$

考虑第 $k+1$ 层，
$[proposition1]$ 把 $k+1$ 层的一半全部填充满，这样整个左子树的节点数就已经是最多且右子树的节点个数不会增加。

{

为了证明 $proposition1$ ,考虑以下情况
第 $k+1$ 层没有填充满，此时继续添加节点，即根节点的左子树节点上加1的同时整个完全二叉树的节点数也在增加。设左子树的节点数为 $a$ ,这样问题就转化为 $\frac{a+1}{n+1}$ 和 $\frac{a}{n}$ 的大小问题。其结论是 当 $n>a>0$ 时，$f(x)=\frac{a+x}{n+x}$ 时单调递增函数，当 $a>n>0$ 时，$f(x)=\frac{a+x}{n+x}$ 时单调递减函数。所以当我们不停的加节点直到 $a=n$ 时停止是我们需要的极端情况，即如果这种情况都 左子树节点数都不会超过 $\frac{2}{3}n$ 则结论成立

}

此时来计算左子树的节点数， 根节点的左子树是一个 $k$ 层的满二叉树 $n_l=2^{k}-1$

总节点数：

$$
n=(2^k-1)+2^{k-1} = 2^{k}(1+\frac{1}{2})-1 = \frac{3}{2}\cdot 2^k-1
$$

所以

$$
\frac{2^k-1}{(3/2)2^k-1} < \frac{2}{3}
$$

恒成立，且在 $k\to \infty$ 时取到 $\Box$

$[Theorem1]$ ：down() 的时间复杂度是 $O(\log{n})$

$proof$ :

有递归算法：
```C
down(i){
    if( left(i)<heap.size && heap[left(i)] > heap[i] )
        largest = left(i);
    else
        largest = right(i);
    if( right(i)<heap.size && heap[right(i)]>heap[largest])
        largest = right(i);
    if( largest != i){
        swap(heap[i], heap[largest]);
        down(largest);
    }
}
```
由Lemma1知，得到递归表达式

$$
\begin{equation}
\begin{split}
    T(n) &\le T(2n/3)+\Theta (1) \\
      &\le T(2^2(n-1)/3^2)+\Theta (1)+\Theta (1) \\
      &...\\
      &\le T(2^n/3^n)+n\Theta (1)
\end{split}
\end{equation}
$$

通过换元得到我们最终的时间复杂度

$$
O(n) = \log_{\frac{3}{2}}{n} = \log{n}
$$

以下是建堆 heapify() 复杂度的推导：
先给出伪代码：
```C
heapify(){
for(int i=n/2; i>=1; i--)
    down(i);
}
```
这里的 `n/2` 是C语言的除，也就是向下取整，记 down 所花费的时间是 $O(h):=ch$ 其中 $c$ 是常数

$[Lemma2]$ 任意一个有 $n$ 个节点的堆，高度为 $h$ 的节点最多有 $\left \lceil n/(2^{h+1}) \right \rceil$ 个

$proof$ :

$def$ : 节点的高度定义为，从这个节点开始到达叶子节点的简单路径中最长的一条的边数。

首先，我们来明确一个堆的性质。堆是一个完全二叉树，其中最后一层可能不满，但其余层必定是满的。

对于任意一个有n个元素的堆，我们想要证明其高度为h的节点数目至多为⌈n/2^{h+1}⌉。

首先，定义堆的高度为H。那么：

1. 高度为0的节点是处于树的最底层的节点，也就是叶子节点。
2. 树的最大高度是 $H$。

那么，一个高度为h的节点在完全二叉树中的层级是 $H-h$。

考虑整个堆的最后一个节点（也就是第n个节点）。它定义了堆中最后一层的大小。因为完全二叉树的层级从上到下增加，所以第 $k$ 层最多有 $2^k$ 个节点。

现在，我们来证明题目中的结论。

考虑高度为h的节点：

1. 如果 $h=0$，那么这些节点是最后一层的节点。假设最后一层有l个节点。那么前 $H-1$ 层有 $n-l$ 个节点，由完全二叉树的性质，$n-l = 2^0 + 2^1 + ... + 2^{H-1} = 2^H - 1$。由此得到 $l = n - 2^H + 1$。但因为 $l ≤ 2^H$，所以 $n - 2^H + 1 ≤ 2^H$，即 $n ≤ 2^{H+1} - 1$。当 $h=0$ 时，最后一层的节点数至多为 $\left \lceil n/2 \right \rceil$。
2. 对于h>0，高度为h的节点在树中的层级是 $H-h$，所以该层有 $2^{H-h}$ 个节点。

因为 $H$ 最大是 $\log_2 {n}，所以 $H-h ≤ \log_2 {n} - h$。此时，$2^{H-h} ≤ 2^{\log_2 {n}-h} = n/2^h$。所以，当 $h>0$ 时，高度为 $h$ 的节点数至多为 $n/2^h$ 

但我们需要进一步考虑高度为h的节点可能存在于最后一层的事实。考虑完整的完全二叉树（也就是堆的最后一层是满的情况），对于高度为 $h$ 的节点来说，节点数为 $2^h$ 。因此，缺失的节点数是 $2^h - \left \lceil n/2^{h+1} \right \rceil$，这个数必须非负，所以 $2^h\ge\left \lceil n/2^{h+1} \right \rceil$ 

综上，高度为h的节点数目确实至多为 $\left \lceil n/2^{h+1} \right \rceil$  $\Box$

$[Lemma3]$ 证明 $\left \lceil n/2^{h+1} \right \rceil\ge 1/2$ 其中 $h\in [0,\left \lfloor  \log{n} \right \rfloor]$

$proof$

即证明 $\left \lceil n/2^{h+1} \right \rceil$ 存在下界 $1/2$, 即当 $h$ 最大时取到，即 $h=\left \lfloor  \log{n} \right \rfloor$

$$
\left \lceil n/2^{\left \lfloor  \log{n} \right \rfloor
+1} \right \rceil = 1/2 \Box
$$

$[Theorem2]$ 设调用高度为 $h$ 的节点的复杂度是 $O(h)$, 则 heapify() 的复杂度是 $O(n)$

$proof$

由Lemma2 得到 heapify() 的一个界为 $\sum_{h=0}^{\left \lfloor  \log{n} \right \rfloor} {\left \lceil n/2^{h+1} \right \rceil}$ ,(这里显示有问题，看下面) 所以

$$
\begin{equation}
\begin{split}
    \sum_{h=0}^{\left \lfloor  \log{n} \right \rfloor} \left \lceil n/2^{h+1} \right \rceil ch &\ge \sum_{h=0}^{\left \lfloor  \log{n} \right \rfloor} \frac{n}{2^h}ch \\
    &=cn\sum_{h=0}^{\left \lfloor  \log{n} \right \rfloor}\frac{h}{2^h}\\
    &\ge cn\sum_{h=0}^{\infty }\frac{h}{2^h} \\
    &\ge cn\cdot \frac{1/2}{(1-1/2)^2} \\
    = O(n)
\end{split}
\end{equation}\Box
$$

# 优先队列
优先级队列是队列的一种扩展，其会将所有元素中优先级最高(或者最低)的元素输出。其实现就是在内部维护一个堆结构

其提供三类核心接口：
* push(): 将元素压入优先队列
* pop(): 将优先级最高或者最低的元素弹出队列
* top(): 将队首的元素(也就是优先级最高的或者最低的元素)的返回出来

具体来说，push是往数组的最后push，然后再调整。pop是先交换，然后删除数组最后一个元素，再调整。

这里，在.h 的实现中，直接使用 heapify() 这样的效率实际上是低的，这里实际上只需要“调整”就可以了。之后再改。



